import { I as It, E as Et, U as Ue, O, $ as $t, T as Te, K as yt, _ as _t, at as Ae, an as globals } from './2-DCRsYQP9.js';
import { c as create_ssr_component, v as validate_component, e as escape, d as add_attribute } from './ssr-C3HYbsxA.js';
import './index-ClteBeTX.js';
import './Component-NmRBwSfF.js';
import 'path';
import 'url';
import 'fs';

const {Object:Ge}=globals,Ye={code:"div.svelte-19qacdz{width:100%;height:100%}#vg-tooltip-element{font-family:var(--font) !important;font-size:var(--text-xs) !important;box-shadow:none !important;background-color:var(--block-background-fill) !important;border:1px solid var(--border-color-primary) !important;color:var(--body-text-color) !important}#vg-tooltip-element .key{color:var(--body-text-color-subdued) !important}.caption.svelte-19qacdz{padding:0 4px;margin:0;text-align:center}",map:'{"version":3,"file":"Index.svelte","sources":["Index.svelte"],"sourcesContent":["<script lang=\\"ts\\">import { BlockTitle } from \\"@gradio/atoms\\";\\nimport { Block } from \\"@gradio/atoms\\";\\nimport { FullscreenButton, IconButtonWrapper, IconButton } from \\"@gradio/atoms\\";\\nimport { StatusTracker } from \\"@gradio/statustracker\\";\\nimport { onMount } from \\"svelte\\";\\nimport { LineChart as LabelIcon, Download } from \\"@gradio/icons\\";\\nimport { Empty } from \\"@gradio/atoms\\";\\nexport let value;\\nexport let x;\\nexport let y;\\nexport let color = null;\\n$: unique_colors = color && value && value.datatypes[color] === \\"nominal\\" ? Array.from(new Set(_data.map((d) => d[color]))) : [];\\nexport let title = null;\\nexport let x_title = null;\\nexport let y_title = null;\\nexport let color_title = null;\\nexport let x_bin = null;\\nexport let y_aggregate = void 0;\\nexport let color_map = null;\\nexport let x_lim = null;\\nexport let y_lim = null;\\n$: x_lim = x_lim || null;\\n$: y_lim = y_lim || null;\\n$: [x_start, x_end] = x_lim === null ? [void 0, void 0] : x_lim;\\n$: [y_start, y_end] = y_lim || [void 0, void 0];\\nexport let x_label_angle = null;\\nexport let y_label_angle = null;\\nexport let x_axis_labels_visible = true;\\nexport let caption = null;\\nexport let sort = null;\\nexport let tooltip = \\"axis\\";\\nexport let show_fullscreen_button = false;\\nexport let show_export_button = false;\\nlet fullscreen = false;\\nfunction reformat_sort(_sort2) {\\n    if (_sort2 === \\"x\\") {\\n        return \\"ascending\\";\\n    }\\n    else if (_sort2 === \\"-x\\") {\\n        return \\"descending\\";\\n    }\\n    else if (_sort2 === \\"y\\") {\\n        return { field: y, order: \\"ascending\\" };\\n    }\\n    else if (_sort2 === \\"-y\\") {\\n        return { field: y, order: \\"descending\\" };\\n    }\\n    else if (_sort2 === null) {\\n        return null;\\n    }\\n    else if (Array.isArray(_sort2)) {\\n        return _sort2;\\n    }\\n}\\n$: _sort = reformat_sort(sort);\\nexport let _selectable = false;\\nlet _data;\\nexport let gradio;\\n$: x_temporal = value && value.datatypes[x] === \\"temporal\\";\\n$: _x_lim = x_lim && x_temporal ? [x_lim[0] * 1e3, x_lim[1] * 1e3] : x_lim;\\nlet _x_bin;\\nlet mouse_down_on_chart = false;\\nconst SUFFIX_DURATION = {\\n    s: 1,\\n    m: 60,\\n    h: 60 * 60,\\n    d: 24 * 60 * 60\\n};\\n$: _x_bin = x_bin ? typeof x_bin === \\"string\\" ? 1e3 * parseInt(x_bin.substring(0, x_bin.length - 1)) * SUFFIX_DURATION[x_bin[x_bin.length - 1]] : x_bin : void 0;\\nlet _y_aggregate;\\nlet aggregating;\\n$: {\\n    if (value) {\\n        if (value.mark === \\"point\\") {\\n            aggregating = _x_bin !== void 0;\\n            _y_aggregate = y_aggregate || aggregating ? \\"sum\\" : void 0;\\n        }\\n        else {\\n            aggregating = _x_bin !== void 0 || value.datatypes[x] === \\"nominal\\";\\n            _y_aggregate = y_aggregate ? y_aggregate : \\"sum\\";\\n        }\\n    }\\n}\\nfunction downsample(data, x_index, y_index, color_index, x_start2, x_end2) {\\n    if (data.length < 1e3 || x_bin !== null || value?.mark !== \\"line\\" || value?.datatypes[x] === \\"nominal\\") {\\n        return data;\\n    }\\n    const bin_count = 250;\\n    let min_max_bins_per_color = {};\\n    if (x_start2 === void 0 || x_end2 === void 0) {\\n        data.forEach((row) => {\\n            let x_value = row[x_index];\\n            if (x_start2 === void 0 || x_value < x_start2) {\\n                x_start2 = x_value;\\n            }\\n            if (x_end2 === void 0 || x_value > x_end2) {\\n                x_end2 = x_value;\\n            }\\n        });\\n    }\\n    if (x_start2 === void 0 || x_end2 === void 0) {\\n        return data;\\n    }\\n    const x_range = x_end2 - x_start2;\\n    const bin_size = x_range / bin_count;\\n    data.forEach((row, i) => {\\n        const x_value = row[x_index];\\n        const y_value = row[y_index];\\n        const color_value = color_index !== null ? row[color_index] : \\"any\\";\\n        const bin_index = Math.floor((x_value - x_start2) / bin_size);\\n        if (min_max_bins_per_color[color_value] === void 0) {\\n            min_max_bins_per_color[color_value] = [];\\n        }\\n        min_max_bins_per_color[color_value][bin_index] = min_max_bins_per_color[color_value][bin_index] || [\\n            null,\\n            Number.POSITIVE_INFINITY,\\n            null,\\n            Number.NEGATIVE_INFINITY\\n        ];\\n        if (y_value < min_max_bins_per_color[color_value][bin_index][1]) {\\n            min_max_bins_per_color[color_value][bin_index][0] = i;\\n            min_max_bins_per_color[color_value][bin_index][1] = y_value;\\n        }\\n        if (y_value > min_max_bins_per_color[color_value][bin_index][3]) {\\n            min_max_bins_per_color[color_value][bin_index][2] = i;\\n            min_max_bins_per_color[color_value][bin_index][3] = y_value;\\n        }\\n    });\\n    const downsampled_data = [];\\n    Object.values(min_max_bins_per_color).forEach((bins) => {\\n        bins.forEach(([min_index, _, max_index, __]) => {\\n            let indices = [];\\n            if (min_index !== null && max_index !== null) {\\n                indices = [\\n                    Math.min(min_index, max_index),\\n                    Math.max(min_index, max_index)\\n                ];\\n            }\\n            else if (min_index !== null) {\\n                indices = [min_index];\\n            }\\n            else if (max_index !== null) {\\n                indices = [max_index];\\n            }\\n            indices.forEach((index) => {\\n                downsampled_data.push(data[index]);\\n            });\\n        });\\n    });\\n    return downsampled_data;\\n}\\nfunction reformat_data(data, x_start2, x_end2) {\\n    let x_index = data.columns.indexOf(x);\\n    let y_index = data.columns.indexOf(y);\\n    let color_index = color ? data.columns.indexOf(color) : null;\\n    let datatable = data.data;\\n    if (x_start2 !== void 0 && x_end2 !== void 0) {\\n        const time_factor = data.datatypes[x] === \\"temporal\\" ? 1e3 : 1;\\n        const _x_start = x_start2 * time_factor;\\n        const _x_end = x_end2 * time_factor;\\n        let largest_before_start = {};\\n        let smallest_after_end = {};\\n        const _datatable = datatable.filter((row, i) => {\\n            const x_value = row[x_index];\\n            const color_value = color_index !== null ? row[color_index] : \\"any\\";\\n            if (x_value < _x_start && (largest_before_start[color_value] === void 0 || x_value > largest_before_start[color_value][1])) {\\n                largest_before_start[color_value] = [i, x_value];\\n            }\\n            if (x_value > _x_end && (smallest_after_end[color_value] === void 0 || x_value < smallest_after_end[color_value][1])) {\\n                smallest_after_end[color_value] = [i, x_value];\\n            }\\n            return x_value >= _x_start && x_value <= _x_end;\\n        });\\n        datatable = [\\n            ...Object.values(largest_before_start).map(([i, _]) => datatable[i]),\\n            ...downsample(_datatable, x_index, y_index, color_index, _x_start, _x_end),\\n            ...Object.values(smallest_after_end).map(([i, _]) => datatable[i])\\n        ];\\n    }\\n    else {\\n        datatable = downsample(datatable, x_index, y_index, color_index, void 0, void 0);\\n    }\\n    if (tooltip == \\"all\\" || Array.isArray(tooltip)) {\\n        return datatable.map((row) => {\\n            const obj = {};\\n            data.columns.forEach((col, i) => {\\n                obj[col] = row[i];\\n            });\\n            return obj;\\n        });\\n    }\\n    return datatable.map((row) => {\\n        const obj = {\\n            [x]: row[x_index],\\n            [y]: row[y_index]\\n        };\\n        if (color && color_index !== null) {\\n            obj[color] = row[color_index];\\n        }\\n        return obj;\\n    });\\n}\\n$: _data = value ? reformat_data(value, x_start, x_end) : [];\\nlet old_value = value;\\n$: if (old_value !== value && view) {\\n    old_value = value;\\n    view.data(\\"data\\", _data).runAsync();\\n}\\nconst is_browser = typeof window !== \\"undefined\\";\\nlet chart_element;\\n$: computed_style = chart_element ? window.getComputedStyle(chart_element) : null;\\nlet view;\\nlet mounted = false;\\nlet old_width;\\nlet old_height;\\nlet resizeObserver;\\nlet vegaEmbed;\\nasync function load_chart() {\\n    if (mouse_down_on_chart) {\\n        refresh_pending = true;\\n        return;\\n    }\\n    if (view) {\\n        view.finalize();\\n    }\\n    if (!value || !chart_element)\\n        return;\\n    old_width = chart_element.offsetWidth;\\n    old_height = chart_element.offsetHeight;\\n    const spec = create_vega_lite_spec();\\n    if (!spec)\\n        return;\\n    resizeObserver = new ResizeObserver((el) => {\\n        if (!el[0].target || !(el[0].target instanceof HTMLElement))\\n            return;\\n        if (old_width === 0 && chart_element.offsetWidth !== 0 && value.datatypes[x] === \\"nominal\\") {\\n            load_chart();\\n        }\\n        else {\\n            const width_change = Math.abs(old_width - el[0].target.offsetWidth);\\n            const height_change = Math.abs(old_height - el[0].target.offsetHeight);\\n            if (width_change > 100 || height_change > 100) {\\n                old_width = el[0].target.offsetWidth;\\n                old_height = el[0].target.offsetHeight;\\n                load_chart();\\n            }\\n            else {\\n                view.signal(\\"width\\", el[0].target.offsetWidth).run();\\n                if (fullscreen) {\\n                    view.signal(\\"height\\", el[0].target.offsetHeight).run();\\n                }\\n            }\\n        }\\n    });\\n    if (!vegaEmbed) {\\n        vegaEmbed = (await import(\\"vega-embed\\")).default;\\n    }\\n    vegaEmbed(chart_element, spec, { actions: false }).then(function (result) {\\n        view = result.view;\\n        resizeObserver.observe(chart_element);\\n        var debounceTimeout;\\n        var lastSelectTime = 0;\\n        view.addEventListener(\\"dblclick\\", () => {\\n            gradio.dispatch(\\"double_click\\");\\n        });\\n        chart_element.addEventListener(\\"mousedown\\", function (e) {\\n            if (e.detail > 1) {\\n                e.preventDefault();\\n            }\\n        }, false);\\n        if (_selectable) {\\n            view.addSignalListener(\\"brush\\", function (_, value2) {\\n                if (Date.now() - lastSelectTime < 1e3)\\n                    return;\\n                mouse_down_on_chart = true;\\n                if (Object.keys(value2).length === 0)\\n                    return;\\n                clearTimeout(debounceTimeout);\\n                let range = value2[Object.keys(value2)[0]];\\n                if (x_temporal) {\\n                    range = [range[0] / 1e3, range[1] / 1e3];\\n                }\\n                debounceTimeout = setTimeout(function () {\\n                    mouse_down_on_chart = false;\\n                    lastSelectTime = Date.now();\\n                    gradio.dispatch(\\"select\\", {\\n                        value: range,\\n                        index: range,\\n                        selected: true\\n                    });\\n                    if (refresh_pending) {\\n                        refresh_pending = false;\\n                        load_chart();\\n                    }\\n                }, 250);\\n            });\\n        }\\n    });\\n}\\nlet refresh_pending = false;\\nonMount(() => {\\n    mounted = true;\\n    return () => {\\n        mounted = false;\\n        if (view) {\\n            view.finalize();\\n        }\\n        if (resizeObserver) {\\n            resizeObserver.disconnect();\\n        }\\n    };\\n});\\nfunction export_chart() {\\n    if (!view || !computed_style)\\n        return;\\n    const block_background = computed_style.getPropertyValue(\\"--block-background-fill\\");\\n    const export_background = block_background || \\"white\\";\\n    view.background(export_background).run();\\n    view.toImageURL(\\"png\\", 2).then(function (url) {\\n        view.background(\\"transparent\\").run();\\n        const link = document.createElement(\\"a\\");\\n        link.setAttribute(\\"href\\", url);\\n        link.setAttribute(\\"download\\", \\"chart.png\\");\\n        link.style.display = \\"none\\";\\n        document.body.appendChild(link);\\n        link.click();\\n        document.body.removeChild(link);\\n    }).catch(function (err) {\\n        console.error(\\"Export failed:\\", err);\\n        view.background(\\"transparent\\").run();\\n    });\\n}\\n$: _color_map = JSON.stringify(color_map);\\n$: title, x_title, y_title, color_title, x, y, color, x_bin, _y_aggregate, _color_map, x_start, x_end, y_start, y_end, caption, sort, mounted, chart_element, fullscreen, computed_style && requestAnimationFrame(load_chart);\\nfunction create_vega_lite_spec() {\\n    if (!value || !computed_style)\\n        return null;\\n    let accent_color = computed_style.getPropertyValue(\\"--color-accent\\");\\n    let body_text_color = computed_style.getPropertyValue(\\"--body-text-color\\");\\n    let borderColorPrimary = computed_style.getPropertyValue(\\"--border-color-primary\\");\\n    let font_family = computed_style.fontFamily;\\n    let title_weight = computed_style.getPropertyValue(\\"--block-title-text-weight\\");\\n    const font_to_px_val = (font) => {\\n        return font.endsWith(\\"px\\") ? parseFloat(font.slice(0, -2)) : 12;\\n    };\\n    let text_size_md = font_to_px_val(computed_style.getPropertyValue(\\"--text-md\\"));\\n    let text_size_sm = font_to_px_val(computed_style.getPropertyValue(\\"--text-sm\\"));\\n    return {\\n        $schema: \\"https://vega.github.io/schema/vega-lite/v5.17.0.json\\",\\n        background: \\"transparent\\",\\n        config: {\\n            autosize: { type: \\"fit\\", contains: \\"padding\\" },\\n            axis: {\\n                labelFont: font_family,\\n                labelColor: body_text_color,\\n                titleFont: font_family,\\n                titleColor: body_text_color,\\n                titlePadding: 8,\\n                tickColor: borderColorPrimary,\\n                labelFontSize: text_size_sm,\\n                gridColor: borderColorPrimary,\\n                titleFontWeight: \\"normal\\",\\n                titleFontSize: text_size_sm,\\n                labelFontWeight: \\"normal\\",\\n                domain: false,\\n                labelAngle: 0,\\n                titleLimit: chart_element.offsetHeight * 0.8\\n            },\\n            legend: {\\n                labelColor: body_text_color,\\n                labelFont: font_family,\\n                titleColor: body_text_color,\\n                titleFont: font_family,\\n                titleFontWeight: \\"normal\\",\\n                titleFontSize: text_size_sm,\\n                labelFontWeight: \\"normal\\",\\n                offset: 2\\n            },\\n            title: {\\n                color: body_text_color,\\n                font: font_family,\\n                fontSize: text_size_md,\\n                fontWeight: title_weight,\\n                anchor: \\"middle\\"\\n            },\\n            view: { stroke: borderColorPrimary },\\n            mark: {\\n                stroke: value.mark !== \\"bar\\" ? accent_color : void 0,\\n                fill: value.mark === \\"bar\\" ? accent_color : void 0,\\n                cursor: \\"crosshair\\"\\n            }\\n        },\\n        data: { name: \\"data\\" },\\n        datasets: {\\n            data: _data\\n        },\\n        layer: [\\"plot\\", ...value.mark === \\"line\\" ? [\\"hover\\"] : []].map((mode) => {\\n            return {\\n                encoding: {\\n                    size: value.mark === \\"line\\" ? mode == \\"plot\\" ? {\\n                        condition: {\\n                            empty: false,\\n                            param: \\"hoverPlot\\",\\n                            value: 3\\n                        },\\n                        value: 2\\n                    } : {\\n                        condition: { empty: false, param: \\"hover\\", value: 100 },\\n                        value: 0\\n                    } : void 0,\\n                    opacity: mode === \\"plot\\" ? void 0 : {\\n                        condition: { empty: false, param: \\"hover\\", value: 1 },\\n                        value: 0\\n                    },\\n                    x: {\\n                        axis: {\\n                            ...x_label_angle !== null && { labelAngle: x_label_angle },\\n                            labels: x_axis_labels_visible,\\n                            ticks: x_axis_labels_visible\\n                        },\\n                        field: x,\\n                        title: x_title || x,\\n                        type: value.datatypes[x],\\n                        scale: _x_lim ? { domain: _x_lim } : void 0,\\n                        bin: _x_bin ? { step: _x_bin } : void 0,\\n                        sort: _sort\\n                    },\\n                    y: {\\n                        axis: y_label_angle ? { labelAngle: y_label_angle } : {},\\n                        field: y,\\n                        title: y_title || y,\\n                        type: value.datatypes[y],\\n                        scale: {\\n                            zero: false,\\n                            domainMin: y_start ?? void 0,\\n                            domainMax: y_end ?? void 0\\n                        },\\n                        aggregate: aggregating ? _y_aggregate : void 0\\n                    },\\n                    color: color ? {\\n                        field: color,\\n                        legend: { orient: \\"bottom\\", title: color_title },\\n                        scale: value.datatypes[color] === \\"nominal\\" ? {\\n                            domain: unique_colors,\\n                            range: color_map ? unique_colors.map((c) => color_map[c]) : void 0\\n                        } : {\\n                            range: [\\n                                100,\\n                                200,\\n                                300,\\n                                400,\\n                                500,\\n                                600,\\n                                700,\\n                                800,\\n                                900\\n                            ].map((n) => computed_style.getPropertyValue(\\"--primary-\\" + n)),\\n                            interpolate: \\"hsl\\"\\n                        },\\n                        type: value.datatypes[color]\\n                    } : void 0,\\n                    tooltip: tooltip == \\"none\\" ? void 0 : [\\n                        {\\n                            field: y,\\n                            type: value.datatypes[y],\\n                            aggregate: aggregating ? _y_aggregate : void 0,\\n                            title: y_title || y\\n                        },\\n                        {\\n                            field: x,\\n                            type: value.datatypes[x],\\n                            title: x_title || x,\\n                            format: x_temporal ? \\"%Y-%m-%d %H:%M:%S\\" : void 0,\\n                            bin: _x_bin ? { step: _x_bin } : void 0\\n                        },\\n                        ...color ? [\\n                            {\\n                                field: color,\\n                                type: value.datatypes[color]\\n                            }\\n                        ] : [],\\n                        ...tooltip === \\"axis\\" ? [] : value?.columns.filter((col) => col !== x && col !== y && col !== color && (tooltip === \\"all\\" || tooltip.includes(col))).map((column) => ({\\n                            field: column,\\n                            type: value.datatypes[column]\\n                        }))\\n                    ]\\n                },\\n                strokeDash: {},\\n                mark: { clip: true, type: mode === \\"hover\\" ? \\"point\\" : value.mark },\\n                name: mode\\n            };\\n        }),\\n        // @ts-ignore\\n        params: [\\n            ...value.mark === \\"line\\" ? [\\n                {\\n                    name: \\"hoverPlot\\",\\n                    select: {\\n                        clear: \\"mouseout\\",\\n                        fields: color ? [color] : [],\\n                        nearest: true,\\n                        on: \\"mouseover\\",\\n                        type: \\"point\\"\\n                    },\\n                    views: [\\"hover\\"]\\n                },\\n                {\\n                    name: \\"hover\\",\\n                    select: {\\n                        clear: \\"mouseout\\",\\n                        nearest: true,\\n                        on: \\"mouseover\\",\\n                        type: \\"point\\"\\n                    },\\n                    views: [\\"hover\\"]\\n                }\\n            ] : [],\\n            ..._selectable ? [\\n                {\\n                    name: \\"brush\\",\\n                    select: {\\n                        encodings: [\\"x\\"],\\n                        mark: { fill: \\"gray\\", fillOpacity: 0.3, stroke: \\"none\\" },\\n                        type: \\"interval\\"\\n                    },\\n                    views: [\\"plot\\"]\\n                }\\n            ] : []\\n        ],\\n        width: chart_element.offsetWidth,\\n        height: height || fullscreen ? \\"container\\" : void 0,\\n        title: title || void 0\\n    };\\n}\\nexport let label = \\"Textbox\\";\\nexport let elem_id = \\"\\";\\nexport let elem_classes = [];\\nexport let visible = true;\\nexport let show_label;\\nexport let scale = null;\\nexport let min_width = void 0;\\nexport let loading_status = void 0;\\nexport let height = void 0;\\n<\/script>\\n\\n<Block\\n\\t{visible}\\n\\t{elem_id}\\n\\t{elem_classes}\\n\\t{scale}\\n\\t{min_width}\\n\\tallow_overflow={false}\\n\\tpadding={true}\\n\\t{height}\\n\\tbind:fullscreen\\n>\\n\\t{#if loading_status}\\n\\t\\t<StatusTracker\\n\\t\\t\\tautoscroll={gradio.autoscroll}\\n\\t\\t\\ti18n={gradio.i18n}\\n\\t\\t\\t{...loading_status}\\n\\t\\t\\ton:clear_status={() => gradio.dispatch(\\"clear_status\\", loading_status)}\\n\\t\\t/>\\n\\t{/if}\\n\\t{#if show_fullscreen_button || show_export_button}\\n\\t\\t<IconButtonWrapper>\\n\\t\\t\\t{#if show_export_button}\\n\\t\\t\\t\\t<IconButton Icon={Download} label=\\"Export\\" on:click={export_chart} />\\n\\t\\t\\t{/if}\\n\\t\\t\\t{#if show_fullscreen_button}\\n\\t\\t\\t\\t<FullscreenButton\\n\\t\\t\\t\\t\\t{fullscreen}\\n\\t\\t\\t\\t\\ton:fullscreen={({ detail }) => {\\n\\t\\t\\t\\t\\t\\tfullscreen = detail;\\n\\t\\t\\t\\t\\t}}\\n\\t\\t\\t\\t/>\\n\\t\\t\\t{/if}\\n\\t\\t</IconButtonWrapper>\\n\\t{/if}\\n\\t<BlockTitle {show_label} info={undefined}>{label}</BlockTitle>\\n\\n\\t{#if value && is_browser}\\n\\t\\t<div bind:this={chart_element}></div>\\n\\n\\t\\t{#if caption}\\n\\t\\t\\t<p class=\\"caption\\">{caption}</p>\\n\\t\\t{/if}\\n\\t{:else}\\n\\t\\t<Empty unpadded_box={true}><LabelIcon /></Empty>\\n\\t{/if}\\n</Block>\\n\\n<style>\\n\\tdiv {\\n\\t\\twidth: 100%;\\n\\t\\theight: 100%;\\n\\t}\\n\\t:global(#vg-tooltip-element) {\\n\\t\\tfont-family: var(--font) !important;\\n\\t\\tfont-size: var(--text-xs) !important;\\n\\t\\tbox-shadow: none !important;\\n\\t\\tbackground-color: var(--block-background-fill) !important;\\n\\t\\tborder: 1px solid var(--border-color-primary) !important;\\n\\t\\tcolor: var(--body-text-color) !important;\\n\\t}\\n\\t:global(#vg-tooltip-element .key) {\\n\\t\\tcolor: var(--body-text-color-subdued) !important;\\n\\t}\\n\\t.caption {\\n\\t\\tpadding: 0 4px;\\n\\t\\tmargin: 0;\\n\\t\\ttext-align: center;\\n\\t}</style>\\n"],"names":[],"mappings":"AAilBC,kBAAI,CACH,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IACT,CACQ,mBAAqB,CAC5B,WAAW,CAAE,IAAI,MAAM,CAAC,CAAC,UAAU,CACnC,SAAS,CAAE,IAAI,SAAS,CAAC,CAAC,UAAU,CACpC,UAAU,CAAE,IAAI,CAAC,UAAU,CAC3B,gBAAgB,CAAE,IAAI,uBAAuB,CAAC,CAAC,UAAU,CACzD,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,sBAAsB,CAAC,CAAC,UAAU,CACxD,KAAK,CAAE,IAAI,iBAAiB,CAAC,CAAC,UAC/B,CACQ,wBAA0B,CACjC,KAAK,CAAE,IAAI,yBAAyB,CAAC,CAAC,UACvC,CACA,uBAAS,CACR,OAAO,CAAE,CAAC,CAAC,GAAG,CACd,MAAM,CAAE,CAAC,CACT,UAAU,CAAE,MACb"}'},et=create_ssr_component((b,e,t,Xe)=>{let te,he,ye,pe,be,Ae$1,U,ne,A,{value:n}=e,{x:v}=e,{y:h}=e,{color:d=null}=e,{title:le=null}=e,{x_title:N=null}=e,{y_title:V=null}=e,{color_title:oe=null}=e,{x_bin:C=null}=e,{y_aggregate:S=void 0}=e,{color_map:W=null}=e,{x_lim:k=null}=e,{y_lim:M=null}=e,{x_label_angle:L=null}=e,{y_label_angle:D=null}=e,{x_axis_labels_visible:H=!0}=e,{caption:q=null}=e,{sort:ae=null}=e,{tooltip:B="axis"}=e,{show_fullscreen_button:K=!1}=e,{show_export_button:R=!1}=e,P=!1;function Ee(l){if(l==="x")return "ascending";if(l==="-x")return "descending";if(l==="y")return {field:h,order:"ascending"};if(l==="-y")return {field:h,order:"descending"};if(l===null)return null;if(Array.isArray(l))return l}let{_selectable:G=!1}=e,Y,{gradio:T}=e,O$1,ie=!1;const ze={s:1,m:60,h:60*60,d:24*60*60};let X,j;function we(l,a,y,c,f,i){if(l.length<1e3||C!==null||n?.mark!=="line"||n?.datatypes[v]==="nominal")return l;const u=250;let o={};if((f===void 0||i===void 0)&&l.forEach(p=>{let x=p[a];(f===void 0||x<f)&&(f=x),(i===void 0||x>i)&&(i=x);}),f===void 0||i===void 0)return l;const s=(i-f)/u;l.forEach((p,x)=>{const z=p[a],g=p[y],r=c!==null?p[c]:"any",_=Math.floor((z-f)/s);o[r]===void 0&&(o[r]=[]),o[r][_]=o[r][_]||[null,Number.POSITIVE_INFINITY,null,Number.NEGATIVE_INFINITY],g<o[r][_][1]&&(o[r][_][0]=x,o[r][_][1]=g),g>o[r][_][3]&&(o[r][_][2]=x,o[r][_][3]=g);});const E=[];return Object.values(o).forEach(p=>{p.forEach(([x,z,g,r])=>{let _=[];x!==null&&g!==null?_=[Math.min(x,g),Math.max(x,g)]:x!==null?_=[x]:g!==null&&(_=[g]),_.forEach(Se=>{E.push(l[Se]);});});}),E}function Be(l,a,y){let c=l.columns.indexOf(v),f=l.columns.indexOf(h),i=d?l.columns.indexOf(d):null,u=l.data;if(a!==void 0&&y!==void 0){const o=l.datatypes[v]==="temporal"?1e3:1,m=a*o,s=y*o;let E={},p={};const x=u.filter((z,g)=>{const r=z[c],_=i!==null?z[i]:"any";return r<m&&(E[_]===void 0||r>E[_][1])&&(E[_]=[g,r]),r>s&&(p[_]===void 0||r<p[_][1])&&(p[_]=[g,r]),r>=m&&r<=s});u=[...Object.values(E).map(([z,g])=>u[z]),...we(x,c,f,i,m,s),...Object.values(p).map(([z,g])=>u[z])];}else u=we(u,c,f,i,void 0,void 0);return B=="all"||Array.isArray(B)?u.map(o=>{const m={};return l.columns.forEach((s,E)=>{m[s]=o[E];}),m}):u.map(o=>{const m={[v]:o[c],[h]:o[f]};return d&&i!==null&&(m[d]=o[i]),m})}let Ce=n;const Fe=typeof window<"u";let I,w,J,re,Q,_e;async function Z(){if(ie){de=!0;return}if(w&&w.finalize(),!n||!I)return;J=I.offsetWidth,re=I.offsetHeight;const l=Oe();l&&(Q=new ResizeObserver(a=>{if(!(!a[0].target||!(a[0].target instanceof HTMLElement)))if(J===0&&I.offsetWidth!==0&&n.datatypes[v]==="nominal")Z();else {const y=Math.abs(J-a[0].target.offsetWidth),c=Math.abs(re-a[0].target.offsetHeight);y>100||c>100?(J=a[0].target.offsetWidth,re=a[0].target.offsetHeight,Z()):(w.signal("width",a[0].target.offsetWidth).run(),P&&w.signal("height",a[0].target.offsetHeight).run());}}),_e||(_e=(await import('./vega-embed.module-Cy8Lv5xT.js')).default),_e(I,l,{actions:!1}).then(function(a){w=a.view,Q.observe(I);var y,c=0;w.addEventListener("dblclick",()=>{T.dispatch("double_click");}),I.addEventListener("mousedown",function(f){f.detail>1&&f.preventDefault();},!1),G&&w.addSignalListener("brush",function(f,i){if(Date.now()-c<1e3||(ie=!0,Object.keys(i).length===0))return;clearTimeout(y);let u=i[Object.keys(i)[0]];U&&(u=[u[0]/1e3,u[1]/1e3]),y=setTimeout(function(){ie=!1,c=Date.now(),T.dispatch("select",{value:u,index:u,selected:!0}),de&&(de=!1,Z());},250);});}));}let de=!1;function Oe(){if(!n||!A)return null;let l=A.getPropertyValue("--color-accent"),a=A.getPropertyValue("--body-text-color"),y=A.getPropertyValue("--border-color-primary"),c=A.fontFamily,f=A.getPropertyValue("--block-title-text-weight");const i=m=>m.endsWith("px")?parseFloat(m.slice(0,-2)):12;let u=i(A.getPropertyValue("--text-md")),o=i(A.getPropertyValue("--text-sm"));return {$schema:"https://vega.github.io/schema/vega-lite/v5.17.0.json",background:"transparent",config:{autosize:{type:"fit",contains:"padding"},axis:{labelFont:c,labelColor:a,titleFont:c,titleColor:a,titlePadding:8,tickColor:y,labelFontSize:o,gridColor:y,titleFontWeight:"normal",titleFontSize:o,labelFontWeight:"normal",domain:!1,labelAngle:0,titleLimit:I.offsetHeight*.8},legend:{labelColor:a,labelFont:c,titleColor:a,titleFont:c,titleFontWeight:"normal",titleFontSize:o,labelFontWeight:"normal",offset:2},title:{color:a,font:c,fontSize:u,fontWeight:f,anchor:"middle"},view:{stroke:y},mark:{stroke:n.mark!=="bar"?l:void 0,fill:n.mark==="bar"?l:void 0,cursor:"crosshair"}},data:{name:"data"},datasets:{data:Y},layer:["plot",...n.mark==="line"?["hover"]:[]].map(m=>({encoding:{size:n.mark==="line"?m=="plot"?{condition:{empty:!1,param:"hoverPlot",value:3},value:2}:{condition:{empty:!1,param:"hover",value:100},value:0}:void 0,opacity:m==="plot"?void 0:{condition:{empty:!1,param:"hover",value:1},value:0},x:{axis:{...L!==null&&{labelAngle:L},labels:H,ticks:H},field:v,title:N||v,type:n.datatypes[v],scale:ne?{domain:ne}:void 0,bin:O$1?{step:O$1}:void 0,sort:Ae$1},y:{axis:D?{labelAngle:D}:{},field:h,title:V||h,type:n.datatypes[h],scale:{zero:!1,domainMin:pe??void 0,domainMax:be??void 0},aggregate:j?X:void 0},color:d?{field:d,legend:{orient:"bottom",title:oe},scale:n.datatypes[d]==="nominal"?{domain:te,range:W?te.map(s=>W[s]):void 0}:{range:[100,200,300,400,500,600,700,800,900].map(s=>A.getPropertyValue("--primary-"+s)),interpolate:"hsl"},type:n.datatypes[d]}:void 0,tooltip:B=="none"?void 0:[{field:h,type:n.datatypes[h],aggregate:j?X:void 0,title:V||h},{field:v,type:n.datatypes[v],title:N||v,format:U?"%Y-%m-%d %H:%M:%S":void 0,bin:O$1?{step:O$1}:void 0},...d?[{field:d,type:n.datatypes[d]}]:[],...B==="axis"?[]:n?.columns.filter(s=>s!==v&&s!==h&&s!==d&&(B==="all"||B.includes(s))).map(s=>({field:s,type:n.datatypes[s]}))]},strokeDash:{},mark:{clip:!0,type:m==="hover"?"point":n.mark},name:m})),params:[...n.mark==="line"?[{name:"hoverPlot",select:{clear:"mouseout",fields:d?[d]:[],nearest:!0,on:"mouseover",type:"point"},views:["hover"]},{name:"hover",select:{clear:"mouseout",nearest:!0,on:"mouseover",type:"point"},views:["hover"]}]:[],...G?[{name:"brush",select:{encodings:["x"],mark:{fill:"gray",fillOpacity:.3,stroke:"none"},type:"interval"},views:["plot"]}]:[]],width:I.offsetWidth,height:ee||P?"container":void 0,title:le||void 0}}let{label:se="Textbox"}=e,{elem_id:ce=""}=e,{elem_classes:ue=[]}=e,{visible:me=!0}=e,{show_label:fe}=e,{scale:ve=null}=e,{min_width:xe=void 0}=e,{loading_status:$=void 0}=e,{height:ee=void 0}=e;e.value===void 0&&t.value&&n!==void 0&&t.value(n),e.x===void 0&&t.x&&v!==void 0&&t.x(v),e.y===void 0&&t.y&&h!==void 0&&t.y(h),e.color===void 0&&t.color&&d!==void 0&&t.color(d),e.title===void 0&&t.title&&le!==void 0&&t.title(le),e.x_title===void 0&&t.x_title&&N!==void 0&&t.x_title(N),e.y_title===void 0&&t.y_title&&V!==void 0&&t.y_title(V),e.color_title===void 0&&t.color_title&&oe!==void 0&&t.color_title(oe),e.x_bin===void 0&&t.x_bin&&C!==void 0&&t.x_bin(C),e.y_aggregate===void 0&&t.y_aggregate&&S!==void 0&&t.y_aggregate(S),e.color_map===void 0&&t.color_map&&W!==void 0&&t.color_map(W),e.x_lim===void 0&&t.x_lim&&k!==void 0&&t.x_lim(k),e.y_lim===void 0&&t.y_lim&&M!==void 0&&t.y_lim(M),e.x_label_angle===void 0&&t.x_label_angle&&L!==void 0&&t.x_label_angle(L),e.y_label_angle===void 0&&t.y_label_angle&&D!==void 0&&t.y_label_angle(D),e.x_axis_labels_visible===void 0&&t.x_axis_labels_visible&&H!==void 0&&t.x_axis_labels_visible(H),e.caption===void 0&&t.caption&&q!==void 0&&t.caption(q),e.sort===void 0&&t.sort&&ae!==void 0&&t.sort(ae),e.tooltip===void 0&&t.tooltip&&B!==void 0&&t.tooltip(B),e.show_fullscreen_button===void 0&&t.show_fullscreen_button&&K!==void 0&&t.show_fullscreen_button(K),e.show_export_button===void 0&&t.show_export_button&&R!==void 0&&t.show_export_button(R),e._selectable===void 0&&t._selectable&&G!==void 0&&t._selectable(G),e.gradio===void 0&&t.gradio&&T!==void 0&&t.gradio(T),e.label===void 0&&t.label&&se!==void 0&&t.label(se),e.elem_id===void 0&&t.elem_id&&ce!==void 0&&t.elem_id(ce),e.elem_classes===void 0&&t.elem_classes&&ue!==void 0&&t.elem_classes(ue),e.visible===void 0&&t.visible&&me!==void 0&&t.visible(me),e.show_label===void 0&&t.show_label&&fe!==void 0&&t.show_label(fe),e.scale===void 0&&t.scale&&ve!==void 0&&t.scale(ve),e.min_width===void 0&&t.min_width&&xe!==void 0&&t.min_width(xe),e.loading_status===void 0&&t.loading_status&&$!==void 0&&t.loading_status($),e.height===void 0&&t.height&&ee!==void 0&&t.height(ee),b.css.add(Ye);let ge,ke,Te$1=b.head;do ge=!0,b.head=Te$1,k=k||null,[he,ye]=k===null?[void 0,void 0]:k,Y=n?Be(n,he,ye):[],te=d&&n&&n.datatypes[d]==="nominal"?Array.from(new Set(Y.map(l=>l[d]))):[],M=M||null,[pe,be]=M||[void 0,void 0],Ae$1=Ee(ae),U=n&&n.datatypes[v]==="temporal",ne=k&&U?[k[0]*1e3,k[1]*1e3]:k,O$1=C?typeof C=="string"?1e3*parseInt(C.substring(0,C.length-1))*ze[C[C.length-1]]:C:void 0,n&&(n.mark==="point"?(j=O$1!==void 0,X=S||j?"sum":void 0):(j=O$1!==void 0||n.datatypes[v]==="nominal",X=S||"sum")),Ce!==n&&w&&(Ce=n,w.data("data",Y).runAsync()),A=null,JSON.stringify(W),A&&requestAnimationFrame(Z),ke=`${validate_component(It,"Block").$$render(b,{visible:me,elem_id:ce,elem_classes:ue,scale:ve,min_width:xe,allow_overflow:!1,padding:!0,height:ee,fullscreen:P},{fullscreen:l=>{P=l,ge=!1;}},{default:()=>`${$?`${validate_component(Et,"StatusTracker").$$render(b,Ge.assign({},{autoscroll:T.autoscroll},{i18n:T.i18n},$),{},{})}`:""} ${K||R?`${validate_component(Ue,"IconButtonWrapper").$$render(b,{},{},{default:()=>`${R?`${validate_component(O,"IconButton").$$render(b,{Icon:$t,label:"Export"},{},{})}`:""} ${K?`${validate_component(Te,"FullscreenButton").$$render(b,{fullscreen:P},{},{})}`:""}`})}`:""} ${validate_component(yt,"BlockTitle").$$render(b,{show_label:fe,info:void 0},{},{default:()=>`${escape(se)}`})} ${n&&Fe?`<div class="svelte-19qacdz"${add_attribute("this",I,0)}></div> ${q?`<p class="caption svelte-19qacdz">${escape(q)}</p>`:""}`:`${validate_component(_t,"Empty").$$render(b,{unpadded_box:!0},{},{default:()=>`${validate_component(Ae,"LabelIcon").$$render(b,{},{},{})}`})}`}`})}`;while(!ge);return ke});

export { et as default };
//# sourceMappingURL=Index29-BPERvxAw.js.map
